### 明确结论：应用的是**软限制** (SetThreadIdealProcessor)

当您在截图所示的区域（核心选择）勾选多个核心（例如 0V, 2V, 4V...），然后在进程列表点击“应用”时，**底层执行的是软限制**。

#### 解析如下：

1.  **用户操作**：
    *   您勾选了一组核心（例如 Core 0, 2, 4）。
    *   点击“应用”。

2.  **代码执行路径** (`src/core/governor.rs`)：
    *   调用 `set_process_affinity(pid, mask)`。
    *   **关键点**：在这个函数内部，我之前已经**移除了** `SetProcessAffinityMask`（硬限制 API）。
    *   **当前逻辑**：
        *   代码会扫描该进程的所有线程。
        *   使用 **Round-Robin (轮询)** 算法，把这些线程依次“建议”给您选中的 Core 0, 2, 4。
        *   调用的 API 是 `SetThreadIdealProcessor`（设置理想处理器）。

3.  **实际效果**：
    *   **非强制**：操作系统会尽量让进程在 Core 0, 2, 4 上跑。
    *   **可溢出**：如果 Core 0, 2, 4 全都满载了，或者被更高优先级的系统任务抢占，进程**会自动**跑到 Core 1, 3, 5 上继续运行，**不会卡死**。

这就是为什么说它是“软限制”——它是一种强烈的建议，但不是绝对的锁死。这对于日常使用和游戏稳定性是最佳选择。