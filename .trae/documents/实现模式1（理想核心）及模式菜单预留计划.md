我将实施“模式1：第一优先核心 (SetThreadIdealProcessor)”功能，并在 UI 中预留模式2/3的入口。

### 1. 核心层 (Core Layer) 扩展

*   **`src/core/types.rs`**:
    *   扩展 `PendingProfile` 结构体，新增 `pub ideal_core: Option<u32>` 字段，用于存储用户选择的理想核心。

*   **`src/core/thread.rs`**:
    *   新增 `set_thread_ideal_processor` 函数。
    *   **实现逻辑**：
        1.  使用 `SetThreadIdealProcessor` Win32 API。由于代码库中目前没有此 API 的绑定，我将使用 `windows::Win32::System::Threading::SetThreadIdealProcessor`。
        2.  逻辑与 `smart_bind_thread` 类似：遍历进程的所有线程，找到最消耗 CPU 的线程（即主线程），对**该线程**设置理想处理器。
        3.  *注意*：`SetThreadIdealProcessor` 是对单个线程的操作，而不是整个进程。

*   **`src/core/governor.rs` (或 `thread.rs`)**:
    *   在应用策略的逻辑中（如果是在 `main` 或 `governor` 中编排），需要增加对 `ideal_core` 字段的处理。当该字段有值时，调用上述 `set_thread_ideal_processor`。

### 2. UI 层 (UI Layer) 修改

*   **`src/ui/app.rs`**:
    *   **右键菜单扩展**：在进程列表的右键菜单中，新增“模式”子菜单。
    *   **菜单项**：
        *   “模式1：第一优先核心” -> 展开核心列表选择器（类似线程绑定）。
        *   “模式2：（待定）” -> 禁用或占位。
        *   “模式3：（待定）” -> 禁用或占位。
    *   **交互逻辑**：
        *   当用户在“模式1”下选择某个核心（如 Core 0）时，不立即执行，而是更新 `PendingProfile` 的 `ideal_core` 字段。
        *   UI 的状态文本（`get_profile_summary`）需要更新，以显示“理想:0”字样。

### 3. 执行步骤

1.  **Core**: 修改 `types.rs` 和 `thread.rs`，实现 API 调用。
2.  **UI**: 修改 `utils.rs` (显示摘要) 和 `app.rs` (右键菜单与策略应用)。

此计划严格遵循您的需求：模式1对应 `SetThreadIdealProcessor`，且仅作为策略的一部分等待用户点击“应用”后执行。