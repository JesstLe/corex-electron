### 结果解析：最终生效的是 **Core 0 (硬绑定)**

这是一个非常极端的冲突场景，Windows 调度器会严格按照“硬限制优先”的规则处理。让我们逐层解析这三个设置叠加后的最终化学反应：

#### 1. 设置叠加分析

1.  **进程核心选择 1-15 (软限制)**：
    *   **您的操作**：在进程列表勾选了 Core 1-15 并点击应用。
    *   **底层行为**：代码通过 `Round-Robin` 轮询，把该进程的所有线程的“理想核心”分别设为 1, 2, 3... 15。
    *   **意图**：建议操作系统把线程安排在 Core 1-15 上跑。

2.  **主线程绑定 0 (硬限制)**：
    *   **您的操作**：右键菜单 -> 线程绑定 -> Core 0。
    *   **底层行为**：调用 `SetThreadAffinityMask(thread_handle, 1 << 0)`。
    *   **意图**：**强制命令**该特定线程（主线程）**只能**在 Core 0 上跑，严禁去其他地方。

3.  **主线程理想 0 (软限制)**：
    *   **您的操作**：右键菜单 -> 模式1 -> Core 0。
    *   **底层行为**：调用 `SetThreadIdealProcessor(thread_handle, 0)`。
    *   **意图**：建议该线程在 Core 0 上跑。

#### 2. 最终冲突裁决

*   **对于主线程 (Main Thread)**：
    *   **生效者**：**绑定 Core 0 (硬限制)**。
    *   **原因**：硬限制是“法律”，软限制是“建议”。当您设置了硬限制 Mask = `0000...0001` (只允许 Core 0) 时，无论您把理想核心设为 0 还是 100，或者之前的进程级软限制设为 1-15，统统无效。该线程将被死死钉在 Core 0 上。
    *   **理想核心冲突**：即使之前的“进程核心选择”建议它去 Core 1，但因为“绑定0”的硬限制存在，调度器根本不会看 Core 1 一眼。后来的“理想0”设置虽然与硬限制一致，但属于脱裤子放屁——硬限制已经保证了它只能在 0 上跑。

*   **对于其他线程 (Worker Threads)**：
    *   **生效者**：**进程核心选择 1-15 (软限制)**。
    *   **原因**：因为您只对主线程做了特殊操作（绑定0、理想0），其他几十个辅助线程依然遵循第一步的“进程核心选择”。
    *   **结果**：它们会乖乖地在 Core 1-15 之间负载均衡，避开 Core 0。

#### 3. 最终效果总结

**这其实是一个非常巧妙的“手动分核”配置！**

*   **Core 0**：**独占** 运行游戏的主线程（因为您硬绑了）。
*   **Core 1-15**：运行游戏的音频、物理、加载等辅助线程（因为进程级软限制）。

**评价**：
如果 Core 0 没有被系统后台任务占满，这种配置能最大化主线程的性能（独占缓存）。但如果 Core 0 此时有系统中断（鼠标/网卡），主线程会因为被“硬绑”在 Core 0 而无法逃逸，导致游戏卡顿。

**建议**：除非您非常确定 Core 0 是空闲的，否则**去掉“绑定0”的硬限制**，只保留“理想0”和“进程1-15”。这样当 Core 0 忙时，主线程还能临时借用 Core 1 跑一下，不至于卡死。